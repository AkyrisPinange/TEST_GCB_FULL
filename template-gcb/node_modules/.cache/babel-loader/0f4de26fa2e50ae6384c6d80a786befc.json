{"ast":null,"code":"'use strict';\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src);\n\n    for (var i = 0, l = props.length; i < l; i++) {\n      dest[props[i]] = src[props[i]];\n    }\n  }\n\n  return dest;\n}\n\nfunction copy(obj) {\n  return extend({}, obj);\n}\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\n\n\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS);\n\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters);\n\n    for (var i = 0, l = chars.length; i < l; i++) {\n      var char = chars[i];\n\n      if (formatCharacters[char] == null) {\n        delete merged[char];\n      } else {\n        merged[char] = formatCharacters[char];\n      }\n    }\n  }\n\n  return merged;\n}\n\nvar ESCAPE_CHAR = '\\\\';\nvar DIGIT_RE = /^\\d$/;\nvar LETTER_RE = /^[A-Za-z]$/;\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/;\nvar DEFAULT_PLACEHOLDER_CHAR = '_';\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function (char) {\n      return ALPHANNUMERIC_RE.test(char);\n    }\n  },\n  '1': {\n    validate: function (char) {\n      return DIGIT_RE.test(char);\n    }\n  },\n  'a': {\n    validate: function (char) {\n      return LETTER_RE.test(char);\n    }\n  },\n  'A': {\n    validate: function (char) {\n      return LETTER_RE.test(char);\n    },\n    transform: function (char) {\n      return char.toUpperCase();\n    }\n  },\n  '#': {\n    validate: function (char) {\n      return ALPHANNUMERIC_RE.test(char);\n    },\n    transform: function (char) {\n      return char.toUpperCase();\n    }\n  }\n};\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\n\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar);\n  }\n  /** Placeholder character */\n\n\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR;\n  /** Format character definitions. */\n\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS;\n  /** Pattern definition string with escape characters. */\n\n  this.source = source;\n  /** Pattern characters after escape characters have been processed. */\n\n  this.pattern = [];\n  /** Length of the pattern after escape characters have been processed. */\n\n  this.length = 0;\n  /** Index of the first editable character. */\n\n  this.firstEditableIndex = null;\n  /** Index of the last editable character. */\n\n  this.lastEditableIndex = null;\n  /** Lookup for indices of editable characters in the pattern. */\n\n  this._editableIndices = {};\n  /** If true, only the pattern before the last valid value character shows. */\n\n  this.isRevealingMask = isRevealingMask || false;\n\n  this._parse();\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('');\n  var patternIndex = 0;\n  var pattern = [];\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i];\n\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR);\n      }\n\n      char = sourceChars[++i];\n    } else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex;\n      }\n\n      this.lastEditableIndex = patternIndex;\n      this._editableIndices[patternIndex] = true;\n    }\n\n    pattern.push(char);\n    patternIndex++;\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error('InputMask: pattern \"' + this.source + '\" does not contain any editable characters.');\n  }\n\n  this.pattern = pattern;\n  this.length = pattern.length;\n};\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\n\n\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length);\n  var valueIndex = 0;\n\n  for (var i = 0, l = this.length; i < l; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask && value.length <= valueIndex && !this.isValidAtIndex(value[valueIndex], i)) {\n        break;\n      }\n\n      valueBuffer[i] = value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i) ? this.transform(value[valueIndex], i) : this.placeholderChar;\n      valueIndex++;\n    } else {\n      valueBuffer[i] = this.pattern[i]; // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++;\n      }\n    }\n  }\n\n  return valueBuffer;\n};\n/**\n * @param {number} index\n * @return {boolean}\n */\n\n\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index];\n};\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\n\n\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char);\n};\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]];\n  return typeof format.transform == 'function' ? format.transform(char) : char;\n};\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) {\n    return new InputMask(options);\n  }\n\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {\n      start: 0,\n      end: 0\n    },\n    value: ''\n  }, options);\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.');\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.');\n  }\n\n  this.placeholderChar = options.placeholderChar;\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters);\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  });\n} // Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\n\n\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end && this.selection.start === this.pattern.length) {\n    return false;\n  }\n\n  var selectionBefore = copy(this.selection);\n  var valueBefore = this.getValue();\n  var inputIndex = this.selection.start; // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex;\n  } // Bail out or add the character to input\n\n\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false;\n    }\n\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex);\n  } // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n\n\n  var end = this.selection.end - 1;\n\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar;\n    }\n\n    end--;\n  } // Advance the cursor to the next character\n\n\n  this.selection.start = this.selection.end = inputIndex + 1; // Skip over any subsequent static characters\n\n  while (this.pattern.length > this.selection.start && !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++;\n    this.selection.end++;\n  } // History\n\n\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n\n    this._historyIndex = null;\n  }\n\n  if (this._lastOp !== 'input' || selectionBefore.start !== selectionBefore.end || this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({\n      value: valueBefore,\n      selection: selectionBefore,\n      lastOp: this._lastOp\n    });\n  }\n\n  this._lastOp = 'input';\n  this._lastSelection = copy(this.selection);\n  return true;\n};\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\n\n\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false;\n  }\n\n  var selectionBefore = copy(this.selection);\n  var valueBefore = this.getValue(); // No range selected - work on the character preceding the cursor\n\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar;\n    }\n\n    this.selection.start--;\n    this.selection.end--;\n  } // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1;\n\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar;\n      }\n\n      end--;\n    }\n\n    this.selection.end = this.selection.start;\n  } // History\n\n\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex);\n  }\n\n  if (this._lastOp !== 'backspace' || selectionBefore.start !== selectionBefore.end || this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({\n      value: valueBefore,\n      selection: selectionBefore,\n      lastOp: this._lastOp\n    });\n  }\n\n  this._lastOp = 'backspace';\n  this._lastSelection = copy(this.selection);\n  return true;\n};\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\n\n\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }; // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false;\n      }\n    } // Continue as if the selection and input started from the editable part of\n    // the pattern.\n\n\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start);\n    this.selection.start = this.pattern.firstEditableIndex;\n  }\n\n  for (i = 0, l = input.length; i < l && this.selection.start <= this.pattern.lastEditableIndex; i++) {\n    var valid = this.input(input.charAt(i)); // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1;\n\n        if (!this.pattern.isEditableIndex(patternIndex) && input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue;\n        }\n      }\n\n      extend(this, initialState);\n      return false;\n    }\n  }\n\n  return true;\n}; // History\n\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false;\n  }\n\n  var historyItem;\n\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1;\n    historyItem = this._history[this._historyIndex]; // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n\n    var value = this.getValue();\n\n    if (historyItem.value !== value || historyItem.selection.start !== this.selection.start || historyItem.selection.end !== this.selection.end) {\n      this._history.push({\n        value: value,\n        selection: copy(this.selection),\n        lastOp: this._lastOp,\n        startUndo: true\n      });\n    }\n  } else {\n    historyItem = this._history[--this._historyIndex];\n  }\n\n  this.value = historyItem.value.split('');\n  this.selection = historyItem.selection;\n  this._lastOp = historyItem.lastOp;\n  return true;\n};\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false;\n  }\n\n  var historyItem = this._history[++this._historyIndex]; // If this is the last history item, we're done redoing\n\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null; // If the last history item was only added to start undoing, remove it\n\n    if (historyItem.startUndo) {\n      this._history.pop();\n    }\n  }\n\n  this.value = historyItem.value.split('');\n  this.selection = historyItem.selection;\n  this._lastOp = historyItem.lastOp;\n  return true;\n}; // Getters & setters\n\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {\n      start: 0,\n      end: 0\n    },\n    value: ''\n  }, options);\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask);\n  this.setValue(options.value);\n  this.emptyValue = this.pattern.formatValue([]).join('');\n  this.selection = options.selection;\n\n  this._resetHistory();\n};\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection);\n\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex;\n      return true;\n    } // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n\n\n    var index = this.selection.start;\n\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) && this.value[index - 1] !== this.placeholderChar || index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index;\n        break;\n      }\n\n      index--;\n    }\n\n    return true;\n  }\n\n  return false;\n};\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = '';\n  }\n\n  this.value = this.pattern.formatValue(value.split(''));\n};\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('');\n};\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = [];\n\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i]);\n    }\n  }\n\n  return rawValue.join('');\n};\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = [];\n  this._historyIndex = null;\n  this._lastOp = null;\n  this._lastSelection = copy(this.selection);\n};\n\nInputMask.Pattern = Pattern;\nmodule.exports = InputMask;","map":{"version":3,"sources":["/Users/effetive/Documents/React-APP/template-gcb/node_modules/inputmask-core/lib/index.js"],"names":["extend","dest","src","props","Object","keys","i","l","length","copy","obj","mergeFormatCharacters","formatCharacters","merged","DEFAULT_FORMAT_CHARACTERS","chars","char","ESCAPE_CHAR","DIGIT_RE","LETTER_RE","ALPHANNUMERIC_RE","DEFAULT_PLACEHOLDER_CHAR","validate","test","transform","toUpperCase","Pattern","source","placeholderChar","isRevealingMask","pattern","firstEditableIndex","lastEditableIndex","_editableIndices","_parse","prototype","parse","sourceChars","split","patternIndex","Error","push","formatValue","format","value","valueBuffer","Array","valueIndex","isEditableIndex","isValidAtIndex","index","InputMask","options","selection","start","end","setPattern","input","selectionBefore","valueBefore","getValue","inputIndex","_historyIndex","_history","splice","_lastOp","_lastSelection","lastOp","backspace","paste","initialState","slice","charAt","substring","valid","undo","historyItem","startUndo","redo","pop","setValue","emptyValue","join","_resetHistory","setSelection","getRawValue","rawValue","module","exports"],"mappings":"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","sourcesContent":["'use strict'\n\nfunction extend(dest, src) {\n  if (src) {\n    var props = Object.keys(src)\n    for (var i = 0, l = props.length; i < l ; i++) {\n      dest[props[i]] = src[props[i]]\n    }\n  }\n  return dest\n}\n\nfunction copy(obj) {\n  return extend({}, obj)\n}\n\n/**\n * Merge an object defining format characters into the defaults.\n * Passing null/undefined for en existing format character removes it.\n * Passing a definition for an existing format character overrides it.\n * @param {?Object} formatCharacters.\n */\nfunction mergeFormatCharacters(formatCharacters) {\n  var merged = copy(DEFAULT_FORMAT_CHARACTERS)\n  if (formatCharacters) {\n    var chars = Object.keys(formatCharacters)\n    for (var i = 0, l = chars.length; i < l ; i++) {\n      var char = chars[i]\n      if (formatCharacters[char] == null) {\n        delete merged[char]\n      }\n      else {\n        merged[char] = formatCharacters[char]\n      }\n    }\n  }\n  return merged\n}\n\nvar ESCAPE_CHAR = '\\\\'\n\nvar DIGIT_RE = /^\\d$/\nvar LETTER_RE = /^[A-Za-z]$/\nvar ALPHANNUMERIC_RE = /^[\\dA-Za-z]$/\n\nvar DEFAULT_PLACEHOLDER_CHAR = '_'\nvar DEFAULT_FORMAT_CHARACTERS = {\n  '*': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) }\n  },\n  '1': {\n    validate: function(char) { return DIGIT_RE.test(char) }\n  },\n  'a': {\n    validate: function(char) { return LETTER_RE.test(char) }\n  },\n  'A': {\n    validate: function(char) { return LETTER_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  },\n  '#': {\n    validate: function(char) { return ALPHANNUMERIC_RE.test(char) },\n    transform: function(char) { return char.toUpperCase() }\n  }\n}\n\n/**\n * @param {string} source\n * @patam {?Object} formatCharacters\n */\nfunction Pattern(source, formatCharacters, placeholderChar, isRevealingMask) {\n  if (!(this instanceof Pattern)) {\n    return new Pattern(source, formatCharacters, placeholderChar)\n  }\n\n  /** Placeholder character */\n  this.placeholderChar = placeholderChar || DEFAULT_PLACEHOLDER_CHAR\n  /** Format character definitions. */\n  this.formatCharacters = formatCharacters || DEFAULT_FORMAT_CHARACTERS\n  /** Pattern definition string with escape characters. */\n  this.source = source\n  /** Pattern characters after escape characters have been processed. */\n  this.pattern = []\n  /** Length of the pattern after escape characters have been processed. */\n  this.length = 0\n  /** Index of the first editable character. */\n  this.firstEditableIndex = null\n  /** Index of the last editable character. */\n  this.lastEditableIndex = null\n  /** Lookup for indices of editable characters in the pattern. */\n  this._editableIndices = {}\n  /** If true, only the pattern before the last valid value character shows. */\n  this.isRevealingMask = isRevealingMask || false\n\n  this._parse()\n}\n\nPattern.prototype._parse = function parse() {\n  var sourceChars = this.source.split('')\n  var patternIndex = 0\n  var pattern = []\n\n  for (var i = 0, l = sourceChars.length; i < l; i++) {\n    var char = sourceChars[i]\n    if (char === ESCAPE_CHAR) {\n      if (i === l - 1) {\n        throw new Error('InputMask: pattern ends with a raw ' + ESCAPE_CHAR)\n      }\n      char = sourceChars[++i]\n    }\n    else if (char in this.formatCharacters) {\n      if (this.firstEditableIndex === null) {\n        this.firstEditableIndex = patternIndex\n      }\n      this.lastEditableIndex = patternIndex\n      this._editableIndices[patternIndex] = true\n    }\n\n    pattern.push(char)\n    patternIndex++\n  }\n\n  if (this.firstEditableIndex === null) {\n    throw new Error(\n      'InputMask: pattern \"' + this.source + '\" does not contain any editable characters.'\n    )\n  }\n\n  this.pattern = pattern\n  this.length = pattern.length\n}\n\n/**\n * @param {Array<string>} value\n * @return {Array<string>}\n */\nPattern.prototype.formatValue = function format(value) {\n  var valueBuffer = new Array(this.length)\n  var valueIndex = 0\n\n  for (var i = 0, l = this.length; i < l ; i++) {\n    if (this.isEditableIndex(i)) {\n      if (this.isRevealingMask &&\n          value.length <= valueIndex &&\n          !this.isValidAtIndex(value[valueIndex], i)) {\n        break\n      }\n      valueBuffer[i] = (value.length > valueIndex && this.isValidAtIndex(value[valueIndex], i)\n                        ? this.transform(value[valueIndex], i)\n                        : this.placeholderChar)\n      valueIndex++\n    }\n    else {\n      valueBuffer[i] = this.pattern[i]\n      // Also allow the value to contain static values from the pattern by\n      // advancing its index.\n      if (value.length > valueIndex && value[valueIndex] === this.pattern[i]) {\n        valueIndex++\n      }\n    }\n  }\n\n  return valueBuffer\n}\n\n/**\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isEditableIndex = function isEditableIndex(index) {\n  return !!this._editableIndices[index]\n}\n\n/**\n * @param {string} char\n * @param {number} index\n * @return {boolean}\n */\nPattern.prototype.isValidAtIndex = function isValidAtIndex(char, index) {\n  return this.formatCharacters[this.pattern[index]].validate(char)\n}\n\nPattern.prototype.transform = function transform(char, index) {\n  var format = this.formatCharacters[this.pattern[index]]\n  return typeof format.transform == 'function' ? format.transform(char) : char\n}\n\nfunction InputMask(options) {\n  if (!(this instanceof InputMask)) { return new InputMask(options) }\n  options = extend({\n    formatCharacters: null,\n    pattern: null,\n    isRevealingMask: false,\n    placeholderChar: DEFAULT_PLACEHOLDER_CHAR,\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n\n  if (options.pattern == null) {\n    throw new Error('InputMask: you must provide a pattern.')\n  }\n\n  if (typeof options.placeholderChar !== 'string' || options.placeholderChar.length > 1) {\n    throw new Error('InputMask: placeholderChar should be a single character or an empty string.')\n  }\n\n  this.placeholderChar = options.placeholderChar\n  this.formatCharacters = mergeFormatCharacters(options.formatCharacters)\n  this.setPattern(options.pattern, {\n    value: options.value,\n    selection: options.selection,\n    isRevealingMask: options.isRevealingMask\n  })\n}\n\n// Editing\n\n/**\n * Applies a single character of input based on the current selection.\n * @param {string} char\n * @return {boolean} true if a change has been made to value or selection as a\n *   result of the input, false otherwise.\n */\nInputMask.prototype.input = function input(char) {\n  // Ignore additional input if the cursor's at the end of the pattern\n  if (this.selection.start === this.selection.end &&\n      this.selection.start === this.pattern.length) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  var inputIndex = this.selection.start\n\n  // If the cursor or selection is prior to the first editable character, make\n  // sure any input given is applied to it.\n  if (inputIndex < this.pattern.firstEditableIndex) {\n    inputIndex = this.pattern.firstEditableIndex\n  }\n\n  // Bail out or add the character to input\n  if (this.pattern.isEditableIndex(inputIndex)) {\n    if (!this.pattern.isValidAtIndex(char, inputIndex)) {\n      return false\n    }\n    this.value[inputIndex] = this.pattern.transform(char, inputIndex)\n  }\n\n  // If multiple characters were selected, blank the remainder out based on the\n  // pattern.\n  var end = this.selection.end - 1\n  while (end > inputIndex) {\n    if (this.pattern.isEditableIndex(end)) {\n      this.value[end] = this.placeholderChar\n    }\n    end--\n  }\n\n  // Advance the cursor to the next character\n  this.selection.start = this.selection.end = inputIndex + 1\n\n  // Skip over any subsequent static characters\n  while (this.pattern.length > this.selection.start &&\n         !this.pattern.isEditableIndex(this.selection.start)) {\n    this.selection.start++\n    this.selection.end++\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n    this._historyIndex = null\n  }\n  if (this._lastOp !== 'input' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'input'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to delete from the value based on the current cursor position or\n * selection.\n * @return {boolean} true if the value or selection changed as the result of\n *   backspacing, false otherwise.\n */\nInputMask.prototype.backspace = function backspace() {\n  // If the cursor is at the start there's nothing to do\n  if (this.selection.start === 0 && this.selection.end === 0) {\n    return false\n  }\n\n  var selectionBefore = copy(this.selection)\n  var valueBefore = this.getValue()\n\n  // No range selected - work on the character preceding the cursor\n  if (this.selection.start === this.selection.end) {\n    if (this.pattern.isEditableIndex(this.selection.start - 1)) {\n      this.value[this.selection.start - 1] = this.placeholderChar\n    }\n    this.selection.start--\n    this.selection.end--\n  }\n  // Range selected - delete characters and leave the cursor at the start of the selection\n  else {\n    var end = this.selection.end - 1\n    while (end >= this.selection.start) {\n      if (this.pattern.isEditableIndex(end)) {\n        this.value[end] = this.placeholderChar\n      }\n      end--\n    }\n    this.selection.end = this.selection.start\n  }\n\n  // History\n  if (this._historyIndex != null) {\n    // Took more input after undoing, so blow any subsequent history away\n    this._history.splice(this._historyIndex, this._history.length - this._historyIndex)\n  }\n  if (this._lastOp !== 'backspace' ||\n      selectionBefore.start !== selectionBefore.end ||\n      this._lastSelection !== null && selectionBefore.start !== this._lastSelection.start) {\n    this._history.push({value: valueBefore, selection: selectionBefore, lastOp: this._lastOp})\n  }\n  this._lastOp = 'backspace'\n  this._lastSelection = copy(this.selection)\n\n  return true\n}\n\n/**\n * Attempts to paste a string of input at the current cursor position or over\n * the top of the current selection.\n * Invalid content at any position will cause the paste to be rejected, and it\n * may contain static parts of the mask's pattern.\n * @param {string} input\n * @return {boolean} true if the paste was successful, false otherwise.\n */\nInputMask.prototype.paste = function paste(input) {\n  // This is necessary because we're just calling input() with each character\n  // and rolling back if any were invalid, rather than checking up-front.\n  var initialState = {\n    value: this.value.slice(),\n    selection: copy(this.selection),\n    _lastOp: this._lastOp,\n    _history: this._history.slice(),\n    _historyIndex: this._historyIndex,\n    _lastSelection: copy(this._lastSelection)\n  }\n\n  // If there are static characters at the start of the pattern and the cursor\n  // or selection is within them, the static characters must match for a valid\n  // paste.\n  if (this.selection.start < this.pattern.firstEditableIndex) {\n    for (var i = 0, l = this.pattern.firstEditableIndex - this.selection.start; i < l; i++) {\n      if (input.charAt(i) !== this.pattern.pattern[i]) {\n        return false\n      }\n    }\n\n    // Continue as if the selection and input started from the editable part of\n    // the pattern.\n    input = input.substring(this.pattern.firstEditableIndex - this.selection.start)\n    this.selection.start = this.pattern.firstEditableIndex\n  }\n\n  for (i = 0, l = input.length;\n       i < l && this.selection.start <= this.pattern.lastEditableIndex;\n       i++) {\n    var valid = this.input(input.charAt(i))\n    // Allow static parts of the pattern to appear in pasted input - they will\n    // already have been stepped over by input(), so verify that the value\n    // deemed invalid by input() was the expected static character.\n    if (!valid) {\n      if (this.selection.start > 0) {\n        // XXX This only allows for one static character to be skipped\n        var patternIndex = this.selection.start - 1\n        if (!this.pattern.isEditableIndex(patternIndex) &&\n            input.charAt(i) === this.pattern.pattern[patternIndex]) {\n          continue\n        }\n      }\n      extend(this, initialState)\n      return false\n    }\n  }\n\n  return true\n}\n\n// History\n\nInputMask.prototype.undo = function undo() {\n  // If there is no history, or nothing more on the history stack, we can't undo\n  if (this._history.length === 0 || this._historyIndex === 0) {\n    return false\n  }\n\n  var historyItem\n  if (this._historyIndex == null) {\n    // Not currently undoing, set up the initial history index\n    this._historyIndex = this._history.length - 1\n    historyItem = this._history[this._historyIndex]\n    // Add a new history entry if anything has changed since the last one, so we\n    // can redo back to the initial state we started undoing from.\n    var value = this.getValue()\n    if (historyItem.value !== value ||\n        historyItem.selection.start !== this.selection.start ||\n        historyItem.selection.end !== this.selection.end) {\n      this._history.push({value: value, selection: copy(this.selection), lastOp: this._lastOp, startUndo: true})\n    }\n  }\n  else {\n    historyItem = this._history[--this._historyIndex]\n  }\n\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\nInputMask.prototype.redo = function redo() {\n  if (this._history.length === 0 || this._historyIndex == null) {\n    return false\n  }\n  var historyItem = this._history[++this._historyIndex]\n  // If this is the last history item, we're done redoing\n  if (this._historyIndex === this._history.length - 1) {\n    this._historyIndex = null\n    // If the last history item was only added to start undoing, remove it\n    if (historyItem.startUndo) {\n      this._history.pop()\n    }\n  }\n  this.value = historyItem.value.split('')\n  this.selection = historyItem.selection\n  this._lastOp = historyItem.lastOp\n  return true\n}\n\n// Getters & setters\n\nInputMask.prototype.setPattern = function setPattern(pattern, options) {\n  options = extend({\n    selection: {start: 0, end: 0},\n    value: ''\n  }, options)\n  this.pattern = new Pattern(pattern, this.formatCharacters, this.placeholderChar, options.isRevealingMask)\n  this.setValue(options.value)\n  this.emptyValue = this.pattern.formatValue([]).join('')\n  this.selection = options.selection\n  this._resetHistory()\n}\n\nInputMask.prototype.setSelection = function setSelection(selection) {\n  this.selection = copy(selection)\n  if (this.selection.start === this.selection.end) {\n    if (this.selection.start < this.pattern.firstEditableIndex) {\n      this.selection.start = this.selection.end = this.pattern.firstEditableIndex\n      return true\n    }\n    // Set selection to the first editable, non-placeholder character before the selection\n    // OR to the beginning of the pattern\n    var index = this.selection.start\n    while (index >= this.pattern.firstEditableIndex) {\n      if (this.pattern.isEditableIndex(index - 1) &&\n          this.value[index - 1] !== this.placeholderChar ||\n          index === this.pattern.firstEditableIndex) {\n        this.selection.start = this.selection.end = index\n        break\n      }\n      index--\n    }\n    return true\n  }\n  return false\n}\n\nInputMask.prototype.setValue = function setValue(value) {\n  if (value == null) {\n    value = ''\n  }\n  this.value = this.pattern.formatValue(value.split(''))\n}\n\nInputMask.prototype.getValue = function getValue() {\n  return this.value.join('')\n}\n\nInputMask.prototype.getRawValue = function getRawValue() {\n  var rawValue = []\n  for (var i = 0; i < this.value.length; i++) {\n    if (this.pattern._editableIndices[i] === true) {\n      rawValue.push(this.value[i])\n    }\n  }\n  return rawValue.join('')\n}\n\nInputMask.prototype._resetHistory = function _resetHistory() {\n  this._history = []\n  this._historyIndex = null\n  this._lastOp = null\n  this._lastSelection = copy(this.selection)\n}\n\nInputMask.Pattern = Pattern\n\nmodule.exports = InputMask\n"]},"metadata":{},"sourceType":"script"}